/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./pages/test3/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/webgl-debug/index.js":
/*!*******************************************!*\
  !*** ./node_modules/webgl-debug/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/*\n** Copyright (c) 2012 The Khronos Group Inc.\n**\n** Permission is hereby granted, free of charge, to any person obtaining a\n** copy of this software and/or associated documentation files (the\n** \"Materials\"), to deal in the Materials without restriction, including\n** without limitation the rights to use, copy, modify, merge, publish,\n** distribute, sublicense, and/or sell copies of the Materials, and to\n** permit persons to whom the Materials are furnished to do so, subject to\n** the following conditions:\n**\n** The above copyright notice and this permission notice shall be included\n** in all copies or substantial portions of the Materials.\n**\n** THE MATERIALS ARE PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.\n*/\n//Ported to node by Marcin Ignac on 2016-05-20\n// Various functions for helping debug WebGL apps.\nWebGLDebugUtils = function () {\n  var window; //polyfill window in node\n\n  if (typeof window == 'undefined') {\n    window = global;\n  }\n  /**\n   * Wrapped logging function.\n   * @param {string} msg Message to log.\n   */\n\n\n  var log = function (msg) {\n    if (window.console && window.console.log) {\n      window.console.log(msg);\n    }\n  };\n  /**\n   * Wrapped error logging function.\n   * @param {string} msg Message to log.\n   */\n\n\n  var error = function (msg) {\n    if (window.console && window.console.error) {\n      window.console.error(msg);\n    } else {\n      log(msg);\n    }\n  };\n  /**\n   * Which arguments are enums based on the number of arguments to the function.\n   * So\n   *    'texImage2D': {\n   *       9: { 0:true, 2:true, 6:true, 7:true },\n   *       6: { 0:true, 2:true, 3:true, 4:true },\n   *    },\n   *\n   * means if there are 9 arguments then 6 and 7 are enums, if there are 6\n   * arguments 3 and 4 are enums\n   *\n   * @type {!Object.<number, !Object.<number, string>}\n   */\n\n\n  var glValidEnumContexts = {\n    // Generic setters and getters\n    'enable': {\n      1: {\n        0: true\n      }\n    },\n    'disable': {\n      1: {\n        0: true\n      }\n    },\n    'getParameter': {\n      1: {\n        0: true\n      }\n    },\n    // Rendering\n    'drawArrays': {\n      3: {\n        0: true\n      }\n    },\n    'drawElements': {\n      4: {\n        0: true,\n        2: true\n      }\n    },\n    // Shaders\n    'createShader': {\n      1: {\n        0: true\n      }\n    },\n    'getShaderParameter': {\n      2: {\n        1: true\n      }\n    },\n    'getProgramParameter': {\n      2: {\n        1: true\n      }\n    },\n    'getShaderPrecisionFormat': {\n      2: {\n        0: true,\n        1: true\n      }\n    },\n    // Vertex attributes\n    'getVertexAttrib': {\n      2: {\n        1: true\n      }\n    },\n    'vertexAttribPointer': {\n      6: {\n        2: true\n      }\n    },\n    // Textures\n    'bindTexture': {\n      2: {\n        0: true\n      }\n    },\n    'activeTexture': {\n      1: {\n        0: true\n      }\n    },\n    'getTexParameter': {\n      2: {\n        0: true,\n        1: true\n      }\n    },\n    'texParameterf': {\n      3: {\n        0: true,\n        1: true\n      }\n    },\n    'texParameteri': {\n      3: {\n        0: true,\n        1: true,\n        2: true\n      }\n    },\n    // texImage2D and texSubImage2D are defined below with WebGL 2 entrypoints\n    'copyTexImage2D': {\n      8: {\n        0: true,\n        2: true\n      }\n    },\n    'copyTexSubImage2D': {\n      8: {\n        0: true\n      }\n    },\n    'generateMipmap': {\n      1: {\n        0: true\n      }\n    },\n    // compressedTexImage2D and compressedTexSubImage2D are defined below with WebGL 2 entrypoints\n    // Buffer objects\n    'bindBuffer': {\n      2: {\n        0: true\n      }\n    },\n    // bufferData and bufferSubData are defined below with WebGL 2 entrypoints\n    'getBufferParameter': {\n      2: {\n        0: true,\n        1: true\n      }\n    },\n    // Renderbuffers and framebuffers\n    'pixelStorei': {\n      2: {\n        0: true,\n        1: true\n      }\n    },\n    // readPixels is defined below with WebGL 2 entrypoints\n    'bindRenderbuffer': {\n      2: {\n        0: true\n      }\n    },\n    'bindFramebuffer': {\n      2: {\n        0: true\n      }\n    },\n    'checkFramebufferStatus': {\n      1: {\n        0: true\n      }\n    },\n    'framebufferRenderbuffer': {\n      4: {\n        0: true,\n        1: true,\n        2: true\n      }\n    },\n    'framebufferTexture2D': {\n      5: {\n        0: true,\n        1: true,\n        2: true\n      }\n    },\n    'getFramebufferAttachmentParameter': {\n      3: {\n        0: true,\n        1: true,\n        2: true\n      }\n    },\n    'getRenderbufferParameter': {\n      2: {\n        0: true,\n        1: true\n      }\n    },\n    'renderbufferStorage': {\n      4: {\n        0: true,\n        1: true\n      }\n    },\n    // Frame buffer operations (clear, blend, depth test, stencil)\n    'clear': {\n      1: {\n        0: {\n          'enumBitwiseOr': ['COLOR_BUFFER_BIT', 'DEPTH_BUFFER_BIT', 'STENCIL_BUFFER_BIT']\n        }\n      }\n    },\n    'depthFunc': {\n      1: {\n        0: true\n      }\n    },\n    'blendFunc': {\n      2: {\n        0: true,\n        1: true\n      }\n    },\n    'blendFuncSeparate': {\n      4: {\n        0: true,\n        1: true,\n        2: true,\n        3: true\n      }\n    },\n    'blendEquation': {\n      1: {\n        0: true\n      }\n    },\n    'blendEquationSeparate': {\n      2: {\n        0: true,\n        1: true\n      }\n    },\n    'stencilFunc': {\n      3: {\n        0: true\n      }\n    },\n    'stencilFuncSeparate': {\n      4: {\n        0: true,\n        1: true\n      }\n    },\n    'stencilMaskSeparate': {\n      2: {\n        0: true\n      }\n    },\n    'stencilOp': {\n      3: {\n        0: true,\n        1: true,\n        2: true\n      }\n    },\n    'stencilOpSeparate': {\n      4: {\n        0: true,\n        1: true,\n        2: true,\n        3: true\n      }\n    },\n    // Culling\n    'cullFace': {\n      1: {\n        0: true\n      }\n    },\n    'frontFace': {\n      1: {\n        0: true\n      }\n    },\n    // ANGLE_instanced_arrays extension\n    'drawArraysInstancedANGLE': {\n      4: {\n        0: true\n      }\n    },\n    'drawElementsInstancedANGLE': {\n      5: {\n        0: true,\n        2: true\n      }\n    },\n    // EXT_blend_minmax extension\n    'blendEquationEXT': {\n      1: {\n        0: true\n      }\n    },\n    // WebGL 2 Buffer objects\n    'bufferData': {\n      3: {\n        0: true,\n        2: true\n      },\n      // WebGL 1\n      4: {\n        0: true,\n        2: true\n      },\n      // WebGL 2\n      5: {\n        0: true,\n        2: true // WebGL 2\n\n      }\n    },\n    'bufferSubData': {\n      3: {\n        0: true\n      },\n      // WebGL 1\n      4: {\n        0: true\n      },\n      // WebGL 2\n      5: {\n        0: true // WebGL 2\n\n      }\n    },\n    'copyBufferSubData': {\n      5: {\n        0: true,\n        1: true\n      }\n    },\n    'getBufferSubData': {\n      3: {\n        0: true\n      },\n      4: {\n        0: true\n      },\n      5: {\n        0: true\n      }\n    },\n    // WebGL 2 Framebuffer objects\n    'blitFramebuffer': {\n      10: {\n        8: {\n          'enumBitwiseOr': ['COLOR_BUFFER_BIT', 'DEPTH_BUFFER_BIT', 'STENCIL_BUFFER_BIT']\n        },\n        9: true\n      }\n    },\n    'framebufferTextureLayer': {\n      5: {\n        0: true,\n        1: true\n      }\n    },\n    'invalidateFramebuffer': {\n      2: {\n        0: true\n      }\n    },\n    'invalidateSubFramebuffer': {\n      6: {\n        0: true\n      }\n    },\n    'readBuffer': {\n      1: {\n        0: true\n      }\n    },\n    // WebGL 2 Renderbuffer objects\n    'getInternalformatParameter': {\n      3: {\n        0: true,\n        1: true,\n        2: true\n      }\n    },\n    'renderbufferStorageMultisample': {\n      5: {\n        0: true,\n        2: true\n      }\n    },\n    // WebGL 2 Texture objects\n    'texStorage2D': {\n      5: {\n        0: true,\n        2: true\n      }\n    },\n    'texStorage3D': {\n      6: {\n        0: true,\n        2: true\n      }\n    },\n    'texImage2D': {\n      9: {\n        0: true,\n        2: true,\n        6: true,\n        7: true\n      },\n      // WebGL 1 & 2\n      6: {\n        0: true,\n        2: true,\n        3: true,\n        4: true\n      },\n      // WebGL 1\n      10: {\n        0: true,\n        2: true,\n        6: true,\n        7: true // WebGL 2\n\n      }\n    },\n    'texImage3D': {\n      10: {\n        0: true,\n        2: true,\n        7: true,\n        8: true\n      },\n      11: {\n        0: true,\n        2: true,\n        7: true,\n        8: true\n      }\n    },\n    'texSubImage2D': {\n      9: {\n        0: true,\n        6: true,\n        7: true\n      },\n      // WebGL 1 & 2\n      7: {\n        0: true,\n        4: true,\n        5: true\n      },\n      // WebGL 1\n      10: {\n        0: true,\n        6: true,\n        7: true // WebGL 2\n\n      }\n    },\n    'texSubImage3D': {\n      11: {\n        0: true,\n        8: true,\n        9: true\n      },\n      12: {\n        0: true,\n        8: true,\n        9: true\n      }\n    },\n    'copyTexSubImage3D': {\n      9: {\n        0: true\n      }\n    },\n    'compressedTexImage2D': {\n      7: {\n        0: true,\n        2: true\n      },\n      // WebGL 1 & 2\n      8: {\n        0: true,\n        2: true\n      },\n      // WebGL 2\n      9: {\n        0: true,\n        2: true // WebGL 2\n\n      }\n    },\n    'compressedTexImage3D': {\n      8: {\n        0: true,\n        2: true\n      },\n      9: {\n        0: true,\n        2: true\n      },\n      10: {\n        0: true,\n        2: true\n      }\n    },\n    'compressedTexSubImage2D': {\n      8: {\n        0: true,\n        6: true\n      },\n      // WebGL 1 & 2\n      9: {\n        0: true,\n        6: true\n      },\n      // WebGL 2\n      10: {\n        0: true,\n        6: true // WebGL 2\n\n      }\n    },\n    'compressedTexSubImage3D': {\n      10: {\n        0: true,\n        8: true\n      },\n      11: {\n        0: true,\n        8: true\n      },\n      12: {\n        0: true,\n        8: true\n      }\n    },\n    // WebGL 2 Vertex attribs\n    'vertexAttribIPointer': {\n      5: {\n        2: true\n      }\n    },\n    // WebGL 2 Writing to the drawing buffer\n    'drawArraysInstanced': {\n      4: {\n        0: true\n      }\n    },\n    'drawElementsInstanced': {\n      5: {\n        0: true,\n        2: true\n      }\n    },\n    'drawRangeElements': {\n      6: {\n        0: true,\n        4: true\n      }\n    },\n    // WebGL 2 Reading back pixels\n    'readPixels': {\n      7: {\n        4: true,\n        5: true\n      },\n      // WebGL 1 & 2\n      8: {\n        4: true,\n        5: true // WebGL 2\n\n      }\n    },\n    // WebGL 2 Multiple Render Targets\n    'clearBufferfv': {\n      3: {\n        0: true\n      },\n      4: {\n        0: true\n      }\n    },\n    'clearBufferiv': {\n      3: {\n        0: true\n      },\n      4: {\n        0: true\n      }\n    },\n    'clearBufferuiv': {\n      3: {\n        0: true\n      },\n      4: {\n        0: true\n      }\n    },\n    'clearBufferfi': {\n      4: {\n        0: true\n      }\n    },\n    // WebGL 2 Query objects\n    'beginQuery': {\n      2: {\n        0: true\n      }\n    },\n    'endQuery': {\n      1: {\n        0: true\n      }\n    },\n    'getQuery': {\n      2: {\n        0: true,\n        1: true\n      }\n    },\n    'getQueryParameter': {\n      2: {\n        1: true\n      }\n    },\n    // WebGL 2 Sampler objects\n    'samplerParameteri': {\n      3: {\n        1: true,\n        2: true\n      }\n    },\n    'samplerParameterf': {\n      3: {\n        1: true\n      }\n    },\n    'getSamplerParameter': {\n      2: {\n        1: true\n      }\n    },\n    // WebGL 2 Sync objects\n    'fenceSync': {\n      2: {\n        0: true,\n        1: {\n          'enumBitwiseOr': []\n        }\n      }\n    },\n    'clientWaitSync': {\n      3: {\n        1: {\n          'enumBitwiseOr': ['SYNC_FLUSH_COMMANDS_BIT']\n        }\n      }\n    },\n    'waitSync': {\n      3: {\n        1: {\n          'enumBitwiseOr': []\n        }\n      }\n    },\n    'getSyncParameter': {\n      2: {\n        1: true\n      }\n    },\n    // WebGL 2 Transform Feedback\n    'bindTransformFeedback': {\n      2: {\n        0: true\n      }\n    },\n    'beginTransformFeedback': {\n      1: {\n        0: true\n      }\n    },\n    'transformFeedbackVaryings': {\n      3: {\n        2: true\n      }\n    },\n    // WebGL2 Uniform Buffer Objects and Transform Feedback Buffers\n    'bindBufferBase': {\n      3: {\n        0: true\n      }\n    },\n    'bindBufferRange': {\n      5: {\n        0: true\n      }\n    },\n    'getIndexedParameter': {\n      2: {\n        0: true\n      }\n    },\n    'getActiveUniforms': {\n      3: {\n        2: true\n      }\n    },\n    'getActiveUniformBlockParameter': {\n      3: {\n        2: true\n      }\n    }\n  };\n  /**\n   * Map of numbers to names.\n   * @type {Object}\n   */\n\n  var glEnums = null;\n  /**\n   * Map of names to numbers.\n   * @type {Object}\n   */\n\n  var enumStringToValue = null;\n  /**\n   * Initializes this module. Safe to call more than once.\n   * @param {!WebGLRenderingContext} ctx A WebGL context. If\n   *    you have more than one context it doesn't matter which one\n   *    you pass in, it is only used to pull out constants.\n   */\n\n  function init(ctx) {\n    if (glEnums == null) {\n      glEnums = {};\n      enumStringToValue = {};\n\n      for (var propertyName in ctx) {\n        if (typeof ctx[propertyName] == 'number') {\n          glEnums[ctx[propertyName]] = propertyName;\n          enumStringToValue[propertyName] = ctx[propertyName];\n        }\n      }\n    }\n  }\n  /**\n   * Checks the utils have been initialized.\n   */\n\n\n  function checkInit() {\n    if (glEnums == null) {\n      throw 'WebGLDebugUtils.init(ctx) not called';\n    }\n  }\n  /**\n   * Returns true or false if value matches any WebGL enum\n   * @param {*} value Value to check if it might be an enum.\n   * @return {boolean} True if value matches one of the WebGL defined enums\n   */\n\n\n  function mightBeEnum(value) {\n    checkInit();\n    return glEnums[value] !== undefined;\n  }\n  /**\n   * Gets an string version of an WebGL enum.\n   *\n   * Example:\n   *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());\n   *\n   * @param {number} value Value to return an enum for\n   * @return {string} The string version of the enum.\n   */\n\n\n  function glEnumToString(value) {\n    checkInit();\n    var name = glEnums[value];\n    return name !== undefined ? \"gl.\" + name : \"/*UNKNOWN WebGL ENUM*/ 0x\" + value.toString(16) + \"\";\n  }\n  /**\n   * Returns the string version of a WebGL argument.\n   * Attempts to convert enum arguments to strings.\n   * @param {string} functionName the name of the WebGL function.\n   * @param {number} numArgs the number of arguments passed to the function.\n   * @param {number} argumentIndx the index of the argument.\n   * @param {*} value The value of the argument.\n   * @return {string} The value as a string.\n   */\n\n\n  function glFunctionArgToString(functionName, numArgs, argumentIndex, value) {\n    var funcInfo = glValidEnumContexts[functionName];\n\n    if (funcInfo !== undefined) {\n      var funcInfo = funcInfo[numArgs];\n\n      if (funcInfo !== undefined) {\n        if (funcInfo[argumentIndex]) {\n          if (typeof funcInfo[argumentIndex] === 'object' && funcInfo[argumentIndex]['enumBitwiseOr'] !== undefined) {\n            var enums = funcInfo[argumentIndex]['enumBitwiseOr'];\n            var orResult = 0;\n            var orEnums = [];\n\n            for (var i = 0; i < enums.length; ++i) {\n              var enumValue = enumStringToValue[enums[i]];\n\n              if ((value & enumValue) !== 0) {\n                orResult |= enumValue;\n                orEnums.push(glEnumToString(enumValue));\n              }\n            }\n\n            if (orResult === value) {\n              return orEnums.join(' | ');\n            } else {\n              return glEnumToString(value);\n            }\n          } else {\n            return glEnumToString(value);\n          }\n        }\n      }\n    }\n\n    if (value === null) {\n      return \"null\";\n    } else if (value === undefined) {\n      return \"undefined\";\n    } else {\n      return value.toString();\n    }\n  }\n  /**\n   * Converts the arguments of a WebGL function to a string.\n   * Attempts to convert enum arguments to strings.\n   *\n   * @param {string} functionName the name of the WebGL function.\n   * @param {number} args The arguments.\n   * @return {string} The arguments as a string.\n   */\n\n\n  function glFunctionArgsToString(functionName, args) {\n    // apparently we can't do args.join(\",\");\n    var argStr = \"\";\n    var numArgs = args.length;\n\n    for (var ii = 0; ii < numArgs; ++ii) {\n      argStr += (ii == 0 ? '' : ', ') + glFunctionArgToString(functionName, numArgs, ii, args[ii]);\n    }\n\n    return argStr;\n  }\n\n  ;\n\n  function makePropertyWrapper(wrapper, original, propertyName) {\n    //log(\"wrap prop: \" + propertyName);\n    wrapper.__defineGetter__(propertyName, function () {\n      return original[propertyName];\n    }); // TODO(gmane): this needs to handle properties that take more than\n    // one value?\n\n\n    wrapper.__defineSetter__(propertyName, function (value) {\n      //log(\"set: \" + propertyName);\n      original[propertyName] = value;\n    });\n  } // Makes a function that calls a function on another object.\n\n\n  function makeFunctionWrapper(original, functionName) {\n    //log(\"wrap fn: \" + functionName);\n    var f = original[functionName];\n    return function () {\n      //log(\"call: \" + functionName);\n      var result = f.apply(original, arguments);\n      return result;\n    };\n  }\n  /**\n   * Given a WebGL context returns a wrapped context that calls\n   * gl.getError after every command and calls a function if the\n   * result is not gl.NO_ERROR.\n   *\n   * @param {!WebGLRenderingContext} ctx The webgl context to\n   *        wrap.\n   * @param {!function(err, funcName, args): void} opt_onErrorFunc\n   *        The function to call when gl.getError returns an\n   *        error. If not specified the default function calls\n   *        console.log with a message.\n   * @param {!function(funcName, args): void} opt_onFunc The\n   *        function to call when each webgl function is called.\n   *        You can use this to log all calls for example.\n   * @param {!WebGLRenderingContext} opt_err_ctx The webgl context\n   *        to call getError on if different than ctx.\n   */\n\n\n  function makeDebugContext(ctx, opt_onErrorFunc, opt_onFunc, opt_err_ctx) {\n    opt_err_ctx = opt_err_ctx || ctx;\n    init(ctx);\n\n    opt_onErrorFunc = opt_onErrorFunc || function (err, functionName, args) {\n      // apparently we can't do args.join(\",\");\n      var argStr = \"\";\n      var numArgs = args.length;\n\n      for (var ii = 0; ii < numArgs; ++ii) {\n        argStr += (ii == 0 ? '' : ', ') + glFunctionArgToString(functionName, numArgs, ii, args[ii]);\n      }\n\n      error(\"WebGL error \" + glEnumToString(err) + \" in \" + functionName + \"(\" + argStr + \")\");\n    }; // Holds booleans for each GL error so after we get the error ourselves\n    // we can still return it to the client app.\n\n\n    var glErrorShadow = {}; // Makes a function that calls a WebGL function and then calls getError.\n\n    function makeErrorWrapper(ctx, functionName) {\n      return function () {\n        if (opt_onFunc) {\n          opt_onFunc(functionName, arguments);\n        }\n\n        var result = ctx[functionName].apply(ctx, arguments);\n        var err = opt_err_ctx.getError();\n\n        if (err != 0) {\n          glErrorShadow[err] = true;\n          opt_onErrorFunc(err, functionName, arguments);\n        }\n\n        return result;\n      };\n    } // Make a an object that has a copy of every property of the WebGL context\n    // but wraps all functions.\n\n\n    var wrapper = {};\n\n    for (var propertyName in ctx) {\n      if (typeof ctx[propertyName] == 'function') {\n        if (propertyName != 'getExtension') {\n          wrapper[propertyName] = makeErrorWrapper(ctx, propertyName);\n        } else {\n          var wrapped = makeErrorWrapper(ctx, propertyName);\n\n          wrapper[propertyName] = function () {\n            var result = wrapped.apply(ctx, arguments);\n\n            if (!result) {\n              return null;\n            }\n\n            return makeDebugContext(result, opt_onErrorFunc, opt_onFunc, opt_err_ctx);\n          };\n        }\n      } else {\n        makePropertyWrapper(wrapper, ctx, propertyName);\n      }\n    } // Override the getError function with one that returns our saved results.\n\n\n    wrapper.getError = function () {\n      for (var err in glErrorShadow) {\n        if (glErrorShadow.hasOwnProperty(err)) {\n          if (glErrorShadow[err]) {\n            glErrorShadow[err] = false;\n            return err;\n          }\n        }\n      }\n\n      return ctx.NO_ERROR;\n    };\n\n    return wrapper;\n  }\n\n  function resetToInitialState(ctx) {\n    var isWebGL2RenderingContext = !!ctx.createTransformFeedback;\n\n    if (isWebGL2RenderingContext) {\n      ctx.bindVertexArray(null);\n    }\n\n    var numAttribs = ctx.getParameter(ctx.MAX_VERTEX_ATTRIBS);\n    var tmp = ctx.createBuffer();\n    ctx.bindBuffer(ctx.ARRAY_BUFFER, tmp);\n\n    for (var ii = 0; ii < numAttribs; ++ii) {\n      ctx.disableVertexAttribArray(ii);\n      ctx.vertexAttribPointer(ii, 4, ctx.FLOAT, false, 0, 0);\n      ctx.vertexAttrib1f(ii, 0);\n\n      if (isWebGL2RenderingContext) {\n        ctx.vertexAttribDivisor(ii, 0);\n      }\n    }\n\n    ctx.deleteBuffer(tmp);\n    var numTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);\n\n    for (var ii = 0; ii < numTextureUnits; ++ii) {\n      ctx.activeTexture(ctx.TEXTURE0 + ii);\n      ctx.bindTexture(ctx.TEXTURE_CUBE_MAP, null);\n      ctx.bindTexture(ctx.TEXTURE_2D, null);\n\n      if (isWebGL2RenderingContext) {\n        ctx.bindTexture(ctx.TEXTURE_2D_ARRAY, null);\n        ctx.bindTexture(ctx.TEXTURE_3D, null);\n        ctx.bindSampler(ii, null);\n      }\n    }\n\n    ctx.activeTexture(ctx.TEXTURE0);\n    ctx.useProgram(null);\n    ctx.bindBuffer(ctx.ARRAY_BUFFER, null);\n    ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);\n    ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);\n    ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);\n    ctx.disable(ctx.BLEND);\n    ctx.disable(ctx.CULL_FACE);\n    ctx.disable(ctx.DEPTH_TEST);\n    ctx.disable(ctx.DITHER);\n    ctx.disable(ctx.SCISSOR_TEST);\n    ctx.blendColor(0, 0, 0, 0);\n    ctx.blendEquation(ctx.FUNC_ADD);\n    ctx.blendFunc(ctx.ONE, ctx.ZERO);\n    ctx.clearColor(0, 0, 0, 0);\n    ctx.clearDepth(1);\n    ctx.clearStencil(-1);\n    ctx.colorMask(true, true, true, true);\n    ctx.cullFace(ctx.BACK);\n    ctx.depthFunc(ctx.LESS);\n    ctx.depthMask(true);\n    ctx.depthRange(0, 1);\n    ctx.frontFace(ctx.CCW);\n    ctx.hint(ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE);\n    ctx.lineWidth(1);\n    ctx.pixelStorei(ctx.PACK_ALIGNMENT, 4);\n    ctx.pixelStorei(ctx.UNPACK_ALIGNMENT, 4);\n    ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, false);\n    ctx.pixelStorei(ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false); // TODO: Delete this IF.\n\n    if (ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL) {\n      ctx.pixelStorei(ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL);\n    }\n\n    ctx.polygonOffset(0, 0);\n    ctx.sampleCoverage(1, false);\n    ctx.scissor(0, 0, ctx.canvas.width, ctx.canvas.height);\n    ctx.stencilFunc(ctx.ALWAYS, 0, 0xFFFFFFFF);\n    ctx.stencilMask(0xFFFFFFFF);\n    ctx.stencilOp(ctx.KEEP, ctx.KEEP, ctx.KEEP);\n    ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);\n    ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT);\n\n    if (isWebGL2RenderingContext) {\n      ctx.drawBuffers([ctx.BACK]);\n      ctx.readBuffer(ctx.BACK);\n      ctx.bindBuffer(ctx.COPY_READ_BUFFER, null);\n      ctx.bindBuffer(ctx.COPY_WRITE_BUFFER, null);\n      ctx.bindBuffer(ctx.PIXEL_PACK_BUFFER, null);\n      ctx.bindBuffer(ctx.PIXEL_UNPACK_BUFFER, null);\n      var numTransformFeedbacks = ctx.getParameter(ctx.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS);\n\n      for (var ii = 0; ii < numTransformFeedbacks; ++ii) {\n        ctx.bindBufferBase(ctx.TRANSFORM_FEEDBACK_BUFFER, ii, null);\n      }\n\n      var numUBOs = ctx.getParameter(ctx.MAX_UNIFORM_BUFFER_BINDINGS);\n\n      for (var ii = 0; ii < numUBOs; ++ii) {\n        ctx.bindBufferBase(ctx.UNIFORM_BUFFER, ii, null);\n      }\n\n      ctx.disable(ctx.RASTERIZER_DISCARD);\n      ctx.pixelStorei(ctx.UNPACK_IMAGE_HEIGHT, 0);\n      ctx.pixelStorei(ctx.UNPACK_SKIP_IMAGES, 0);\n      ctx.pixelStorei(ctx.UNPACK_ROW_LENGTH, 0);\n      ctx.pixelStorei(ctx.UNPACK_SKIP_ROWS, 0);\n      ctx.pixelStorei(ctx.UNPACK_SKIP_PIXELS, 0);\n      ctx.pixelStorei(ctx.PACK_ROW_LENGTH, 0);\n      ctx.pixelStorei(ctx.PACK_SKIP_ROWS, 0);\n      ctx.pixelStorei(ctx.PACK_SKIP_PIXELS, 0);\n      ctx.hint(ctx.FRAGMENT_SHADER_DERIVATIVE_HINT, ctx.DONT_CARE);\n    } // TODO: This should NOT be needed but Firefox fails with 'hint'\n\n\n    while (ctx.getError());\n  }\n\n  function makeLostContextSimulatingCanvas(canvas) {\n    var unwrappedContext_;\n    var wrappedContext_;\n    var onLost_ = [];\n    var onRestored_ = [];\n    var wrappedContext_ = {};\n    var contextId_ = 1;\n    var contextLost_ = false;\n    var resourceId_ = 0;\n    var resourceDb_ = [];\n    var numCallsToLoseContext_ = 0;\n    var numCalls_ = 0;\n    var canRestore_ = false;\n    var restoreTimeout_ = 0;\n    var isWebGL2RenderingContext; // Holds booleans for each GL error so can simulate errors.\n\n    var glErrorShadow_ = {};\n\n    canvas.getContext = function (f) {\n      return function () {\n        var ctx = f.apply(canvas, arguments); // Did we get a context and is it a WebGL context?\n\n        if (ctx instanceof WebGLRenderingContext || window.WebGL2RenderingContext && ctx instanceof WebGL2RenderingContext) {\n          if (ctx != unwrappedContext_) {\n            if (unwrappedContext_) {\n              throw \"got different context\";\n            }\n\n            isWebGL2RenderingContext = window.WebGL2RenderingContext && ctx instanceof WebGL2RenderingContext;\n            unwrappedContext_ = ctx;\n            wrappedContext_ = makeLostContextSimulatingContext(unwrappedContext_);\n          }\n\n          return wrappedContext_;\n        }\n\n        return ctx;\n      };\n    }(canvas.getContext);\n\n    function wrapEvent(listener) {\n      if (typeof listener == \"function\") {\n        return listener;\n      } else {\n        return function (info) {\n          listener.handleEvent(info);\n        };\n      }\n    }\n\n    var addOnContextLostListener = function (listener) {\n      onLost_.push(wrapEvent(listener));\n    };\n\n    var addOnContextRestoredListener = function (listener) {\n      onRestored_.push(wrapEvent(listener));\n    };\n\n    function wrapAddEventListener(canvas) {\n      var f = canvas.addEventListener;\n\n      canvas.addEventListener = function (type, listener, bubble) {\n        switch (type) {\n          case 'webglcontextlost':\n            addOnContextLostListener(listener);\n            break;\n\n          case 'webglcontextrestored':\n            addOnContextRestoredListener(listener);\n            break;\n\n          default:\n            f.apply(canvas, arguments);\n        }\n      };\n    }\n\n    wrapAddEventListener(canvas);\n\n    canvas.loseContext = function () {\n      if (!contextLost_) {\n        contextLost_ = true;\n        numCallsToLoseContext_ = 0;\n        ++contextId_;\n\n        while (unwrappedContext_.getError());\n\n        clearErrors();\n        glErrorShadow_[unwrappedContext_.CONTEXT_LOST_WEBGL] = true;\n        var event = makeWebGLContextEvent(\"context lost\");\n        var callbacks = onLost_.slice();\n        setTimeout(function () {\n          //log(\"numCallbacks:\" + callbacks.length);\n          for (var ii = 0; ii < callbacks.length; ++ii) {\n            //log(\"calling callback:\" + ii);\n            callbacks[ii](event);\n          }\n\n          if (restoreTimeout_ >= 0) {\n            setTimeout(function () {\n              canvas.restoreContext();\n            }, restoreTimeout_);\n          }\n        }, 0);\n      }\n    };\n\n    canvas.restoreContext = function () {\n      if (contextLost_) {\n        if (onRestored_.length) {\n          setTimeout(function () {\n            if (!canRestore_) {\n              throw \"can not restore. webglcontestlost listener did not call event.preventDefault\";\n            }\n\n            freeResources();\n            resetToInitialState(unwrappedContext_);\n            contextLost_ = false;\n            numCalls_ = 0;\n            canRestore_ = false;\n            var callbacks = onRestored_.slice();\n            var event = makeWebGLContextEvent(\"context restored\");\n\n            for (var ii = 0; ii < callbacks.length; ++ii) {\n              callbacks[ii](event);\n            }\n          }, 0);\n        }\n      }\n    };\n\n    canvas.loseContextInNCalls = function (numCalls) {\n      if (contextLost_) {\n        throw \"You can not ask a lost contet to be lost\";\n      }\n\n      numCallsToLoseContext_ = numCalls_ + numCalls;\n    };\n\n    canvas.getNumCalls = function () {\n      return numCalls_;\n    };\n\n    canvas.setRestoreTimeout = function (timeout) {\n      restoreTimeout_ = timeout;\n    };\n\n    function isWebGLObject(obj) {\n      //return false;\n      return obj instanceof WebGLBuffer || obj instanceof WebGLFramebuffer || obj instanceof WebGLProgram || obj instanceof WebGLRenderbuffer || obj instanceof WebGLShader || obj instanceof WebGLTexture;\n    }\n\n    function checkResources(args) {\n      for (var ii = 0; ii < args.length; ++ii) {\n        var arg = args[ii];\n\n        if (isWebGLObject(arg)) {\n          return arg.__webglDebugContextLostId__ == contextId_;\n        }\n      }\n\n      return true;\n    }\n\n    function clearErrors() {\n      var k = Object.keys(glErrorShadow_);\n\n      for (var ii = 0; ii < k.length; ++ii) {\n        delete glErrorShadow_[k[ii]];\n      }\n    }\n\n    function loseContextIfTime() {\n      ++numCalls_;\n\n      if (!contextLost_) {\n        if (numCallsToLoseContext_ == numCalls_) {\n          canvas.loseContext();\n        }\n      }\n    } // Makes a function that simulates WebGL when out of context.\n\n\n    function makeLostContextFunctionWrapper(ctx, functionName) {\n      var f = ctx[functionName];\n      return function () {\n        // log(\"calling:\" + functionName);\n        // Only call the functions if the context is not lost.\n        loseContextIfTime();\n\n        if (!contextLost_) {\n          //if (!checkResources(arguments)) {\n          //  glErrorShadow_[wrappedContext_.INVALID_OPERATION] = true;\n          //  return;\n          //}\n          var result = f.apply(ctx, arguments);\n          return result;\n        }\n      };\n    }\n\n    function freeResources() {\n      for (var ii = 0; ii < resourceDb_.length; ++ii) {\n        var resource = resourceDb_[ii];\n\n        if (resource instanceof WebGLBuffer) {\n          unwrappedContext_.deleteBuffer(resource);\n        } else if (resource instanceof WebGLFramebuffer) {\n          unwrappedContext_.deleteFramebuffer(resource);\n        } else if (resource instanceof WebGLProgram) {\n          unwrappedContext_.deleteProgram(resource);\n        } else if (resource instanceof WebGLRenderbuffer) {\n          unwrappedContext_.deleteRenderbuffer(resource);\n        } else if (resource instanceof WebGLShader) {\n          unwrappedContext_.deleteShader(resource);\n        } else if (resource instanceof WebGLTexture) {\n          unwrappedContext_.deleteTexture(resource);\n        } else if (isWebGL2RenderingContext) {\n          if (resource instanceof WebGLQuery) {\n            unwrappedContext_.deleteQuery(resource);\n          } else if (resource instanceof WebGLSampler) {\n            unwrappedContext_.deleteSampler(resource);\n          } else if (resource instanceof WebGLSync) {\n            unwrappedContext_.deleteSync(resource);\n          } else if (resource instanceof WebGLTransformFeedback) {\n            unwrappedContext_.deleteTransformFeedback(resource);\n          } else if (resource instanceof WebGLVertexArrayObject) {\n            unwrappedContext_.deleteVertexArray(resource);\n          }\n        }\n      }\n    }\n\n    function makeWebGLContextEvent(statusMessage) {\n      return {\n        statusMessage: statusMessage,\n        preventDefault: function () {\n          canRestore_ = true;\n        }\n      };\n    }\n\n    return canvas;\n\n    function makeLostContextSimulatingContext(ctx) {\n      // copy all functions and properties to wrapper\n      for (var propertyName in ctx) {\n        if (typeof ctx[propertyName] == 'function') {\n          wrappedContext_[propertyName] = makeLostContextFunctionWrapper(ctx, propertyName);\n        } else {\n          makePropertyWrapper(wrappedContext_, ctx, propertyName);\n        }\n      } // Wrap a few functions specially.\n\n\n      wrappedContext_.getError = function () {\n        loseContextIfTime();\n\n        if (!contextLost_) {\n          var err;\n\n          while (err = unwrappedContext_.getError()) {\n            glErrorShadow_[err] = true;\n          }\n        }\n\n        for (var err in glErrorShadow_) {\n          if (glErrorShadow_[err]) {\n            delete glErrorShadow_[err];\n            return err;\n          }\n        }\n\n        return wrappedContext_.NO_ERROR;\n      };\n\n      var creationFunctions = [\"createBuffer\", \"createFramebuffer\", \"createProgram\", \"createRenderbuffer\", \"createShader\", \"createTexture\"];\n\n      if (isWebGL2RenderingContext) {\n        creationFunctions.push(\"createQuery\", \"createSampler\", \"fenceSync\", \"createTransformFeedback\", \"createVertexArray\");\n      }\n\n      for (var ii = 0; ii < creationFunctions.length; ++ii) {\n        var functionName = creationFunctions[ii];\n\n        wrappedContext_[functionName] = function (f) {\n          return function () {\n            loseContextIfTime();\n\n            if (contextLost_) {\n              return null;\n            }\n\n            var obj = f.apply(ctx, arguments);\n            obj.__webglDebugContextLostId__ = contextId_;\n            resourceDb_.push(obj);\n            return obj;\n          };\n        }(ctx[functionName]);\n      }\n\n      var functionsThatShouldReturnNull = [\"getActiveAttrib\", \"getActiveUniform\", \"getBufferParameter\", \"getContextAttributes\", \"getAttachedShaders\", \"getFramebufferAttachmentParameter\", \"getParameter\", \"getProgramParameter\", \"getProgramInfoLog\", \"getRenderbufferParameter\", \"getShaderParameter\", \"getShaderInfoLog\", \"getShaderSource\", \"getTexParameter\", \"getUniform\", \"getUniformLocation\", \"getVertexAttrib\"];\n\n      if (isWebGL2RenderingContext) {\n        functionsThatShouldReturnNull.push(\"getInternalformatParameter\", \"getQuery\", \"getQueryParameter\", \"getSamplerParameter\", \"getSyncParameter\", \"getTransformFeedbackVarying\", \"getIndexedParameter\", \"getUniformIndices\", \"getActiveUniforms\", \"getActiveUniformBlockParameter\", \"getActiveUniformBlockName\");\n      }\n\n      for (var ii = 0; ii < functionsThatShouldReturnNull.length; ++ii) {\n        var functionName = functionsThatShouldReturnNull[ii];\n\n        wrappedContext_[functionName] = function (f) {\n          return function () {\n            loseContextIfTime();\n\n            if (contextLost_) {\n              return null;\n            }\n\n            return f.apply(ctx, arguments);\n          };\n        }(wrappedContext_[functionName]);\n      }\n\n      var isFunctions = [\"isBuffer\", \"isEnabled\", \"isFramebuffer\", \"isProgram\", \"isRenderbuffer\", \"isShader\", \"isTexture\"];\n\n      if (isWebGL2RenderingContext) {\n        isFunctions.push(\"isQuery\", \"isSampler\", \"isSync\", \"isTransformFeedback\", \"isVertexArray\");\n      }\n\n      for (var ii = 0; ii < isFunctions.length; ++ii) {\n        var functionName = isFunctions[ii];\n\n        wrappedContext_[functionName] = function (f) {\n          return function () {\n            loseContextIfTime();\n\n            if (contextLost_) {\n              return false;\n            }\n\n            return f.apply(ctx, arguments);\n          };\n        }(wrappedContext_[functionName]);\n      }\n\n      wrappedContext_.checkFramebufferStatus = function (f) {\n        return function () {\n          loseContextIfTime();\n\n          if (contextLost_) {\n            return wrappedContext_.FRAMEBUFFER_UNSUPPORTED;\n          }\n\n          return f.apply(ctx, arguments);\n        };\n      }(wrappedContext_.checkFramebufferStatus);\n\n      wrappedContext_.getAttribLocation = function (f) {\n        return function () {\n          loseContextIfTime();\n\n          if (contextLost_) {\n            return -1;\n          }\n\n          return f.apply(ctx, arguments);\n        };\n      }(wrappedContext_.getAttribLocation);\n\n      wrappedContext_.getVertexAttribOffset = function (f) {\n        return function () {\n          loseContextIfTime();\n\n          if (contextLost_) {\n            return 0;\n          }\n\n          return f.apply(ctx, arguments);\n        };\n      }(wrappedContext_.getVertexAttribOffset);\n\n      wrappedContext_.isContextLost = function () {\n        return contextLost_;\n      };\n\n      if (isWebGL2RenderingContext) {\n        wrappedContext_.getFragDataLocation = function (f) {\n          return function () {\n            loseContextIfTime();\n\n            if (contextLost_) {\n              return -1;\n            }\n\n            return f.apply(ctx, arguments);\n          };\n        }(wrappedContext_.getFragDataLocation);\n\n        wrappedContext_.clientWaitSync = function (f) {\n          return function () {\n            loseContextIfTime();\n\n            if (contextLost_) {\n              return wrappedContext_.WAIT_FAILED;\n            }\n\n            return f.apply(ctx, arguments);\n          };\n        }(wrappedContext_.clientWaitSync);\n\n        wrappedContext_.getUniformBlockIndex = function (f) {\n          return function () {\n            loseContextIfTime();\n\n            if (contextLost_) {\n              return wrappedContext_.INVALID_INDEX;\n            }\n\n            return f.apply(ctx, arguments);\n          };\n        }(wrappedContext_.getUniformBlockIndex);\n      }\n\n      return wrappedContext_;\n    }\n  }\n\n  return {\n    /**\n     * Initializes this module. Safe to call more than once.\n     * @param {!WebGLRenderingContext} ctx A WebGL context. If\n     *    you have more than one context it doesn't matter which one\n     *    you pass in, it is only used to pull out constants.\n     */\n    'init': init,\n\n    /**\n     * Returns true or false if value matches any WebGL enum\n     * @param {*} value Value to check if it might be an enum.\n     * @return {boolean} True if value matches one of the WebGL defined enums\n     */\n    'mightBeEnum': mightBeEnum,\n\n    /**\n     * Gets an string version of an WebGL enum.\n     *\n     * Example:\n     *   WebGLDebugUtil.init(ctx);\n     *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());\n     *\n     * @param {number} value Value to return an enum for\n     * @return {string} The string version of the enum.\n     */\n    'glEnumToString': glEnumToString,\n\n    /**\n     * Converts the argument of a WebGL function to a string.\n     * Attempts to convert enum arguments to strings.\n     *\n     * Example:\n     *   WebGLDebugUtil.init(ctx);\n     *   var str = WebGLDebugUtil.glFunctionArgToString('bindTexture', 2, 0, gl.TEXTURE_2D);\n     *\n     * would return 'TEXTURE_2D'\n     *\n     * @param {string} functionName the name of the WebGL function.\n     * @param {number} numArgs The number of arguments\n     * @param {number} argumentIndx the index of the argument.\n     * @param {*} value The value of the argument.\n     * @return {string} The value as a string.\n     */\n    'glFunctionArgToString': glFunctionArgToString,\n\n    /**\n     * Converts the arguments of a WebGL function to a string.\n     * Attempts to convert enum arguments to strings.\n     *\n     * @param {string} functionName the name of the WebGL function.\n     * @param {number} args The arguments.\n     * @return {string} The arguments as a string.\n     */\n    'glFunctionArgsToString': glFunctionArgsToString,\n\n    /**\n     * Given a WebGL context returns a wrapped context that calls\n     * gl.getError after every command and calls a function if the\n     * result is not NO_ERROR.\n     *\n     * You can supply your own function if you want. For example, if you'd like\n     * an exception thrown on any GL error you could do this\n     *\n     *    function throwOnGLError(err, funcName, args) {\n     *      throw WebGLDebugUtils.glEnumToString(err) +\n     *            \" was caused by call to \" + funcName;\n     *    };\n     *\n     *    ctx = WebGLDebugUtils.makeDebugContext(\n     *        canvas.getContext(\"webgl\"), throwOnGLError);\n     *\n     * @param {!WebGLRenderingContext} ctx The webgl context to wrap.\n     * @param {!function(err, funcName, args): void} opt_onErrorFunc The function\n     *     to call when gl.getError returns an error. If not specified the default\n     *     function calls console.log with a message.\n     * @param {!function(funcName, args): void} opt_onFunc The\n     *     function to call when each webgl function is called. You\n     *     can use this to log all calls for example.\n     */\n    'makeDebugContext': makeDebugContext,\n\n    /**\n     * Given a canvas element returns a wrapped canvas element that will\n     * simulate lost context. The canvas returned adds the following functions.\n     *\n     * loseContext:\n     *   simulates a lost context event.\n     *\n     * restoreContext:\n     *   simulates the context being restored.\n     *\n     * lostContextInNCalls:\n     *   loses the context after N gl calls.\n     *\n     * getNumCalls:\n     *   tells you how many gl calls there have been so far.\n     *\n     * setRestoreTimeout:\n     *   sets the number of milliseconds until the context is restored\n     *   after it has been lost. Defaults to 0. Pass -1 to prevent\n     *   automatic restoring.\n     *\n     * @param {!Canvas} canvas The canvas element to wrap.\n     */\n    'makeLostContextSimulatingCanvas': makeLostContextSimulatingCanvas,\n\n    /**\n     * Resets a context to the initial state.\n     * @param {!WebGLRenderingContext} ctx The webgl context to\n     *     reset.\n     */\n    'resetToInitialState': resetToInitialState\n  };\n}();\n\nmodule.exports = WebGLDebugUtils;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/webgl-debug/index.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g; // This works in non-strict mode\n\ng = function () {\n  return this;\n}();\n\ntry {\n  // This works if eval is allowed (see CSP)\n  g = g || new Function(\"return this\")();\n} catch (e) {\n  // This works if the window reference is available\n  if (typeof window === \"object\") g = window;\n} // g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\n\nmodule.exports = g;\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./pages/test3/fish2.jpg":
/*!*******************************!*\
  !*** ./pages/test3/fish2.jpg ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"3bf111812a04a4c3a04ded9b97fd313a.jpg\";\n\n//# sourceURL=webpack:///./pages/test3/fish2.jpg?");

/***/ }),

/***/ "./pages/test3/index.js":
/*!******************************!*\
  !*** ./pages/test3/index.js ***!
  \******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var webgl_debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webgl-debug */ \"./node_modules/webgl-debug/index.js\");\n/* harmony import */ var webgl_debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(webgl_debug__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matrix */ \"./pages/test3/matrix.js\");\n/* harmony import */ var _fish2_jpg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fish2.jpg */ \"./pages/test3/fish2.jpg\");\n/* harmony import */ var _fish2_jpg__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_fish2_jpg__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n/**\n * A very simple webGL demo,that it includes most of techniques of using WebGl--GLSL ES,basic animation,\n * texture,light and shadow--delivers a introduction on allmost everything you need to get going.\n */\n// Vertex shader program for generating a shadow map\n\nvar SHADOW_VSHADER_SOURCE = 'attribute vec4 a_Position;\\n' + 'uniform mat4 u_MvpMatrix;\\n' + 'void main() {\\n' + '  gl_Position = u_MvpMatrix * a_Position;\\n' + '}\\n'; // Fragment shader program for generating a shadow map\n\nvar SHADOW_FSHADER_SOURCE = '#ifdef GL_ES\\n' + 'precision mediump float;\\n' + '#endif\\n' + 'void main() {\\n' + '  gl_FragColor = vec4(gl_FragCoord.z, 0.0, 0.0, 1.0);\\n' + // Write the z-value in R\n'}\\n'; //shaders program for main view\n\nvar VSHADER_SOURCE = 'attribute vec4 a_Position;\\n' + 'attribute vec4 a_Color;\\n' + 'attribute vec2 a_TexCoord;\\n' + 'attribute vec4 a_Normal;\\n' + 'uniform mat4 u_MvpMatrixFromLight;\\n' + 'varying vec4 v_PositionFromLight;\\n' + 'varying vec2 v_TexCoord;\\n' + 'uniform mat4 u_MvpMatrix;\\n' + 'varying vec4 v_Color;\\n' + 'varying vec4 v_Normal;\\n' + 'varying vec4 v_Position;\\n' + 'void main(){\\n' + 'gl_Position=u_MvpMatrix*a_Position;\\n' + 'v_TexCoord=a_TexCoord;\\n' + 'v_Color=a_Color;\\n' + 'v_Normal=a_Normal;\\n' + 'v_Position=a_Position;\\n' + 'v_PositionFromLight = u_MvpMatrixFromLight * a_Position;\\n' + '}\\n';\nvar FSHADER_SOURCE = '#ifdef GL_ES\\n' + 'precision highp float;\\n' + '#endif\\n' + 'uniform vec4 u_lightPosition;\\n' + 'uniform sampler2D u_Sampler;\\n' + 'uniform mat4 u_NormalMatrix;\\n' + 'uniform sampler2D u_ShadowMap;\\n' + 'uniform int u_Ifcolor;\\n' + 'varying vec2 v_TexCoord;\\n' + 'varying vec4 v_Color;\\n' + 'varying vec4 v_Normal;\\n' + 'varying vec4 v_Position;\\n' + 'varying vec4 v_PositionFromLight;\\n' + 'void main(){\\n' + 'vec3 shadowCoord = (v_PositionFromLight.xyz/v_PositionFromLight.w)/2.0 + 0.5;\\n' + 'vec4 rgbaDepth = texture2D(u_ShadowMap, shadowCoord.xy);\\n' + 'float depth = rgbaDepth.r;\\n' + // Retrieve the z-value from R\n'float visibility = (shadowCoord.z > depth+0.005) ? 0.4 : 1.0;\\n' + 'vec3 environment=vec3(0.5,0.5,0.5);\\n' + 'vec3 LightColor=vec3(1.0,1.0,1.0);\\n' + 'vec3 normal=normalize(vec3(u_NormalMatrix*v_Normal));\\n' + 'vec3 LightDirection=normalize(vec3(u_lightPosition)-vec3(v_Position));\\n' + 'float nDotL=max(dot(LightDirection,normal),0.0);\\n' + 'vec3 diffuse;\\n' + 'vec3 environmentColor;\\n' + 'if(u_Ifcolor!=0){\\n' + 'diffuse=LightColor*vec3(texture2D(u_Sampler,v_TexCoord))*nDotL*visibility;\\n' + 'environmentColor=environment*vec3(texture2D(u_Sampler,v_TexCoord));\\n' + '}else{\\n' + 'diffuse=LightColor*vec3(v_Color)*nDotL*visibility;\\n' + 'environmentColor=environment*vec3(v_Color);\\n' + '}\\n' + 'gl_FragColor =vec4(diffuse+environmentColor,1.0);\\n' + '}\\n';\nvar OFFSCREEN_WIDTH = 1024;\nvar OFFSCREEN_HEIGHT = 1024;\n\nfunction startDraw(image) {\n  // Retrieve <canvas> element\n  var canvas = document.getElementById(\"myGLCanvas\"); // Get the rendering context for WebGL\n\n  var gl = getWebGLContext(canvas);\n\n  if (!gl) {\n    console.log(\"failed to get context\");\n    return;\n  } // Set the clear color and enable the depth test\n\n\n  gl.clearColor(0.0, 0.0, 0.0, 1.0);\n  gl.enable(gl.DEPTH_TEST); //Set viewport\n\n  gl.viewport(0, 0, OFFSCREEN_WIDTH, OFFSCREEN_HEIGHT); // Initialize shaders for regular drawing\n\n  var realProgram = initProgram(gl, VSHADER_SOURCE, FSHADER_SOURCE);\n  var realMatrix = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Matrix4\"]();\n  realMatrix.setPerspective(45, 1, 1, 100);\n  realMatrix.lookAt(3.0, 3.0, 6.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);\n  realProgram.a_Position = gl.getAttribLocation(realProgram, 'a_Position');\n  realProgram.a_Color = gl.getAttribLocation(realProgram, 'a_Color');\n  realProgram.a_TexCoord = gl.getAttribLocation(realProgram, 'a_TexCoord');\n  realProgram.a_Normal = gl.getAttribLocation(realProgram, 'a_Normal');\n  realProgram.u_Sampler = gl.getUniformLocation(realProgram, 'u_Sampler');\n  realProgram.u_lightPosition = gl.getUniformLocation(realProgram, 'u_lightPosition');\n  realProgram.u_NormalMatrix = gl.getUniformLocation(realProgram, 'u_NormalMatrix');\n  realProgram.u_MvpMatrix = gl.getUniformLocation(realProgram, 'u_MvpMatrix');\n  realProgram.u_ShadowMap = gl.getUniformLocation(realProgram, 'u_ShadowMap');\n  realProgram.u_Ifcolor = gl.getUniformLocation(realProgram, 'u_Ifcolor');\n  realProgram.u_MvpMatrixFromLight = gl.getUniformLocation(realProgram, 'u_MvpMatrixFromLight'); // Initialize shaders for generating a shadow map\n\n  var shadowProgram = initProgram(gl, SHADOW_VSHADER_SOURCE, SHADOW_FSHADER_SOURCE);\n  var shadowMatrix = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Matrix4\"]();\n  shadowMatrix.setPerspective(70, 1, 1, 100);\n  shadowMatrix.lookAt(5.0, 5.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);\n  shadowProgram.a_Position = gl.getAttribLocation(shadowProgram, 'a_Position');\n  shadowProgram.u_MvpMatrix = gl.getUniformLocation(shadowProgram, 'u_MvpMatrix'); // Initialize framebuffer object (FBO)  \n\n  var fbo = initFramebufferObject(gl); // Initialize objects \n\n  var square = initSquare(gl);\n  var cube = initCube(gl, image); // Calculate the matrix\n\n  square.matrix.rotate(-90, 1.0, 0.0, 1.0).scale(2.0, 2.0, 2.0).translate(-1.0, 0.0, 0.0);\n  cube.matrix.scale(0.3, 0.3, 0.3).translate(0.0, 6.0, 2.0); //Animation function\n\n  var tick = function tick() {\n    cube.matrix.rotate(2, 0.0, 1.0, 1.0); //Move the eye point to the position of the light source and draw objects from there.\n\n    gl.useProgram(shadowProgram);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\n    gl.viewport(0, 0, OFFSCREEN_WIDTH, OFFSCREEN_WIDTH);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    draw(gl, shadowProgram, square, shadowMatrix);\n    draw(gl, shadowProgram, cube, shadowMatrix); //Move the eye point back to the position from which you want to view the objects and draw them from there.\n\n    gl.useProgram(realProgram);\n    gl.activeTexture(gl.TEXTURE1);\n    gl.bindTexture(gl.TEXTURE_2D, fbo.texture);\n    gl.uniform1i(realProgram.u_ShadowMap, 1);\n    gl.uniform4f(realProgram.u_lightPosition, 5.0, 9.0, 5.0, 1.0);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.viewport(0, 0, 800, 800);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); //draw square\n\n    var squareM = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Matrix4\"]();\n    squareM.set(shadowMatrix);\n    squareM.multiply(square.matrix);\n    gl.uniformMatrix4fv(realProgram.u_MvpMatrixFromLight, false, squareM.elements);\n    draw(gl, realProgram, square, realMatrix); //draw cube\n\n    var cubeM = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Matrix4\"]();\n    cubeM.set(shadowMatrix);\n    cubeM.multiply(cube.matrix);\n    gl.uniformMatrix4fv(realProgram.u_MvpMatrixFromLight, false, cubeM.elements);\n    draw(gl, realProgram, cube, realMatrix);\n    window.requestAnimationFrame(tick, canvas1);\n  }; //go\n\n\n  tick();\n} //initSquare\n\n\nfunction initSquare(gl, image) {\n  // Vertex coordinates\n  var squareVertex = new Float32Array([0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 1.5, -1.0, 0.0, 1.5, 1.0, 0.0]);\n  var squareColors = new Float32Array([0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]);\n  var squareIndice = new Uint8Array([0, 1, 2, 0, 2, 3]);\n  var squareCoord = new Float32Array([0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0]);\n  var squareNormal = new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0]);\n  console.log(image);\n  var mMatrix = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Matrix4\"]();\n  mMatrix.setTranslate(0.0, 0.0, 0.0);\n  var nMatrix = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Matrix4\"]();\n  nMatrix.setInverseOf(mMatrix);\n  nMatrix.transpose();\n  var square = {\n    'vertex': initBuffer(gl, squareVertex),\n    'colors': initBuffer(gl, squareColors),\n    'indice': initElementBuffer(gl, squareIndice),\n    'normal': initBuffer(gl, squareNormal),\n    'coord': initBuffer(gl, squareCoord),\n    'vertexNumber': squareIndice.length,\n    'matrix': mMatrix,\n    'normalMatrix': nMatrix,\n    'ifcolor': 0\n  };\n  return square;\n} //initCube\n\n\nfunction initCube(gl) {\n  var cubeVertex = new Float32Array([1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, // v0-v1-v2-v3 front\n  1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, // v0-v3-v4-v5 right\n  1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, // v0-v5-v6-v1 up\n  -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, // v1-v6-v7-v2 left\n  -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, // v7-v4-v3-v2 down\n  1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0 // v4-v7-v6-v5 back\n  ]);\n  var cubeColors = new Float32Array([0.2, 0.58, 0.82, 0.2, 0.58, 0.82, 0.2, 0.58, 0.82, 0.2, 0.58, 0.82, // v0-v1-v2-v3 front\n  0.5, 0.41, 0.69, 0.5, 0.41, 0.69, 0.5, 0.41, 0.69, 0.5, 0.41, 0.69, // v0-v3-v4-v5 right\n  0.0, 0.32, 0.61, 0.0, 0.32, 0.61, 0.0, 0.32, 0.61, 0.0, 0.32, 0.61, // v0-v5-v6-v1 up\n  0.78, 0.69, 0.84, 0.78, 0.69, 0.84, 0.78, 0.69, 0.84, 0.78, 0.69, 0.84, // v1-v6-v7-v2 left\n  0.32, 0.18, 0.56, 0.32, 0.18, 0.56, 0.32, 0.18, 0.56, 0.32, 0.18, 0.56, // v7-v4-v3-v2 down\n  0.73, 0.82, 0.93, 0.73, 0.82, 0.93, 0.73, 0.82, 0.93, 0.73, 0.82, 0.93]);\n  var cubeIndice = new Uint8Array([0, 1, 2, 0, 2, 3, // front\n  4, 5, 6, 4, 6, 7, // right\n  8, 9, 10, 8, 10, 11, // up\n  12, 13, 14, 12, 14, 15, // left\n  16, 17, 18, 16, 18, 19, // down\n  20, 21, 22, 20, 22, 23 // back\n  ]);\n  var cubeNormal = new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, // v0-v1-v2-v3 front\n  1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, // v0-v3-v4-v5 right\n  0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, // v0-v5-v6-v1 up\n  -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, // v1-v6-v7-v2 left\n  0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, // v7-v4-v3-v2 down\n  0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0 // v4-v7-v6-v5 back\n  ]);\n  var cubeCoord = new Float32Array([1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, // v0-v1-v2-v3 front\n  0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, // v0-v3-v4-v5 right\n  1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, // v0-v5-v6-v1 up\n  1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, // v1-v6-v7-v2 left\n  0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, // v7-v4-v3-v2 down\n  0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0 // v4-v7-v6-v5 back\n  ]);\n  var image = document.getElementById('image');\n  var mMatrix = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Matrix4\"]();\n  mMatrix.setTranslate(0.0, 0.0, 0.0);\n  var nMatrix = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Matrix4\"]();\n  nMatrix.setInverseOf(mMatrix);\n  nMatrix.transpose();\n  var cube = {\n    'vertex': initBuffer(gl, cubeVertex),\n    'colors': initBuffer(gl, cubeColors),\n    'indice': initElementBuffer(gl, cubeIndice),\n    'normal': initBuffer(gl, cubeNormal),\n    'coord': initBuffer(gl, cubeCoord),\n    'texture': initTexture(gl, image),\n    'vertexNumber': cubeIndice.length,\n    'matrix': mMatrix,\n    'normalMatrix': nMatrix,\n    'ifcolor': 1\n  };\n  return cube;\n} //draw\n\n\nfunction draw(gl, realProgram, element, mMatrix) {\n  var tempMatrix = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"Matrix4\"]();\n  tempMatrix.set(mMatrix);\n  tempMatrix.multiply(element.matrix);\n  gl.uniformMatrix4fv(realProgram.u_MvpMatrix, false, tempMatrix.elements);\n\n  if (realProgram.u_NormalMatrix != undefined) {\n    gl.uniformMatrix4fv(realProgram.u_NormalMatrix, false, element.normalMatrix.elements);\n  }\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, element.vertex);\n  gl.vertexAttribPointer(realProgram.a_Position, 3, gl.FLOAT, false, 0, 0);\n  gl.enableVertexAttribArray(realProgram.a_Position);\n\n  if (realProgram.a_TexCoord != undefined) {\n    gl.bindBuffer(gl.ARRAY_BUFFER, element.coord);\n    gl.vertexAttribPointer(realProgram.a_TexCoord, 2, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(realProgram.a_TexCoord);\n  }\n\n  if (realProgram.a_Normal != undefined) {\n    gl.bindBuffer(gl.ARRAY_BUFFER, element.normal);\n    gl.vertexAttribPointer(realProgram.a_Normal, 3, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(realProgram.a_Normal);\n  }\n\n  if (realProgram.a_Color != undefined) {\n    gl.bindBuffer(gl.ARRAY_BUFFER, element.colors);\n    gl.vertexAttribPointer(realProgram.a_Color, 3, gl.FLOAT, false, 0, 0);\n    gl.enableVertexAttribArray(realProgram.a_Color);\n  }\n\n  if (realProgram.u_Sampler != undefined && element.ifcolor != 0) {\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, element.texture);\n    gl.uniform1i(realProgram.u_Sampler, 0);\n  }\n\n  gl.uniform1i(realProgram.u_Ifcolor, element.ifcolor);\n  gl.bindBuffer(gl.ARRAY_BUFFER, null);\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, element.indice);\n  gl.drawElements(gl.TRIANGLES, element.vertexNumber, gl.UNSIGNED_BYTE, 0);\n}\n\nfunction initBuffer(gl, array) {\n  var buffer = gl.createBuffer();\n\n  if (!buffer) {\n    console.log('Failed to create the buffer object');\n    return null;\n  }\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  gl.bufferData(gl.ARRAY_BUFFER, array, gl.STATIC_DRAW);\n  gl.bindBuffer(gl.ARRAY_BUFFER, null);\n  return buffer;\n}\n\nfunction initElementBuffer(gl, array) {\n  var buffer = gl.createBuffer();\n\n  if (!buffer) {\n    console.log('Failed to create the buffer object');\n    return null;\n  }\n\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array, gl.STATIC_DRAW);\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n  return buffer;\n}\n\nfunction initTexture(gl, image) {\n  var texture = gl.createTexture();\n  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);\n  gl.activeTexture(gl.TEXTURE1);\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  return texture;\n}\n\nfunction initFramebufferObject(gl) {\n  var framebuffer, texture, depthBuffer;\n  framebuffer = gl.createFramebuffer();\n  texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, OFFSCREEN_WIDTH, OFFSCREEN_HEIGHT, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n  framebuffer.texture = texture;\n  depthBuffer = gl.createRenderbuffer();\n  gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);\n  gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, OFFSCREEN_WIDTH, OFFSCREEN_HEIGHT);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);\n  var e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n\n  if (gl.FRAMEBUFFER_COMPLETE !== e) {\n    console.log('Frame buffer object is incomplete: ' + e.toString());\n    return error();\n  }\n\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n  return framebuffer;\n}\n\nfunction initProgram(gl, vshader, fshader) {\n  var program = createProgram(gl, vshader, fshader);\n\n  if (!program) {\n    console.log('Failed to create program');\n    return false;\n  }\n\n  return program;\n}\n\nfunction createProgram(gl, vshader, fshader) {\n  var vertexShader = loadShader(gl, gl.VERTEX_SHADER, vshader);\n  var fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fshader);\n\n  if (!vertexShader || !fragmentShader) {\n    return null;\n  }\n\n  var program = gl.createProgram();\n\n  if (!program) {\n    return null;\n  }\n\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n\n  if (!linked) {\n    var error = gl.getProgramInfoLog(program);\n    console.log('Failed to link program: ' + error);\n    gl.deleteProgram(program);\n    gl.deleteShader(fragmentShader);\n    gl.deleteShader(vertexShader);\n    return null;\n  }\n\n  return program;\n}\n\nfunction loadShader(gl, type, source) {\n  var shader = gl.createShader(type);\n\n  if (shader == null) {\n    console.log('unable to create shader');\n    return null;\n  }\n\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n  if (!compiled) {\n    var error = gl.getShaderInfoLog(shader);\n    console.log('Failed to compile shader: ' + error);\n    gl.deleteShader(shader);\n    return null;\n  }\n\n  return shader;\n}\n\nfunction getWebGLContext(canvas, opt_debug) {\n  var gl = create3DContext(canvas);\n  if (!gl) return null;\n  return gl;\n}\n\nvar create3DContext = function create3DContext(canvas, opt_attribs) {\n  var names = [\"webgl\", \"experimental-webgl\", \"webkit-3d\", \"moz-webgl\"];\n  var context = null;\n\n  for (var ii = 0; ii < names.length; ++ii) {\n    try {\n      context = canvas.getContext(names[ii], opt_attribs);\n    } catch (e) {}\n\n    if (context) {\n      break;\n    }\n  }\n\n  return context;\n};\n\nfunction startup() {\n  var image = new Image();\n  image.src = _fish2_jpg__WEBPACK_IMPORTED_MODULE_2___default.a;\n  document.addEventListener('load', function () {\n    startDraw(image);\n  });\n}\n\nwindow.onload = startup;\n\n//# sourceURL=webpack:///./pages/test3/index.js?");

/***/ }),

/***/ "./pages/test3/matrix.js":
/*!*******************************!*\
  !*** ./pages/test3/matrix.js ***!
  \*******************************/
/*! exports provided: Matrix4, Vector3, Vector4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Matrix4\", function() { return Matrix4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vector3\", function() { return Vector3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vector4\", function() { return Vector4; });\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n// cuon-matrix.js (c) 2012 kanda and matsuda\n\n/** \n * This is a class treating 4x4 matrix.\n * This class contains the function that is equivalent to OpenGL matrix stack.\n * The matrix after conversion is calculated by multiplying a conversion matrix from the right.\n * The matrix is replaced by the calculated result.\n */\n\n/**\n * Constructor of Matrix4\n * If opt_src is specified, new matrix is initialized by opt_src.\n * Otherwise, new matrix is initialized by identity matrix.\n * @param opt_src source matrix(option)\n */\nvar Matrix4 = function Matrix4(opt_src) {\n  var i, s, d;\n\n  if (opt_src && _typeof(opt_src) === 'object' && opt_src.hasOwnProperty('elements')) {\n    s = opt_src.elements;\n    d = new Float32Array(16);\n\n    for (i = 0; i < 16; ++i) {\n      d[i] = s[i];\n    }\n\n    this.elements = d;\n  } else {\n    this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n  }\n};\n/**\n * Set the identity matrix.\n * @return this\n */\n\n\nMatrix4.prototype.setIdentity = function () {\n  var e = this.elements;\n  e[0] = 1;\n  e[4] = 0;\n  e[8] = 0;\n  e[12] = 0;\n  e[1] = 0;\n  e[5] = 1;\n  e[9] = 0;\n  e[13] = 0;\n  e[2] = 0;\n  e[6] = 0;\n  e[10] = 1;\n  e[14] = 0;\n  e[3] = 0;\n  e[7] = 0;\n  e[11] = 0;\n  e[15] = 1;\n  return this;\n};\n/**\n * Copy matrix.\n * @param src source matrix\n * @return this\n */\n\n\nMatrix4.prototype.set = function (src) {\n  var i, s, d;\n  s = src.elements;\n  d = this.elements;\n\n  if (s === d) {\n    return;\n  }\n\n  for (i = 0; i < 16; ++i) {\n    d[i] = s[i];\n  }\n\n  return this;\n};\n/**\n * Multiply the matrix from the right.\n * @param other The multiply matrix\n * @return this\n */\n\n\nMatrix4.prototype.concat = function (other) {\n  var i, e, a, b, ai0, ai1, ai2, ai3; // Calculate e = a * b\n\n  e = this.elements;\n  a = this.elements;\n  b = other.elements; // If e equals b, copy b to temporary matrix.\n\n  if (e === b) {\n    b = new Float32Array(16);\n\n    for (i = 0; i < 16; ++i) {\n      b[i] = e[i];\n    }\n  }\n\n  for (i = 0; i < 4; i++) {\n    ai0 = a[i];\n    ai1 = a[i + 4];\n    ai2 = a[i + 8];\n    ai3 = a[i + 12];\n    e[i] = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3];\n    e[i + 4] = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7];\n    e[i + 8] = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11];\n    e[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];\n  }\n\n  return this;\n};\n\nMatrix4.prototype.multiply = Matrix4.prototype.concat;\n/**\n * Multiply the three-dimensional vector.\n * @param pos  The multiply vector\n * @return The result of multiplication(Float32Array)\n */\n\nMatrix4.prototype.multiplyVector3 = function (pos) {\n  var e = this.elements;\n  var p = pos.elements;\n  var v = new Vector3();\n  var result = v.elements;\n  result[0] = p[0] * e[0] + p[1] * e[4] + p[2] * e[8] + e[11];\n  result[1] = p[0] * e[1] + p[1] * e[5] + p[2] * e[9] + e[12];\n  result[2] = p[0] * e[2] + p[1] * e[6] + p[2] * e[10] + e[13];\n  return v;\n};\n/**\n * Multiply the four-dimensional vector.\n * @param pos  The multiply vector\n * @return The result of multiplication(Float32Array)\n */\n\n\nMatrix4.prototype.multiplyVector4 = function (pos) {\n  var e = this.elements;\n  var p = pos.elements;\n  var v = new Vector4();\n  var result = v.elements;\n  result[0] = p[0] * e[0] + p[1] * e[4] + p[2] * e[8] + p[3] * e[12];\n  result[1] = p[0] * e[1] + p[1] * e[5] + p[2] * e[9] + p[3] * e[13];\n  result[2] = p[0] * e[2] + p[1] * e[6] + p[2] * e[10] + p[3] * e[14];\n  result[3] = p[0] * e[3] + p[1] * e[7] + p[2] * e[11] + p[3] * e[15];\n  return v;\n};\n/**\n * Transpose the matrix.\n * @return this\n */\n\n\nMatrix4.prototype.transpose = function () {\n  var e, t;\n  e = this.elements;\n  t = e[1];\n  e[1] = e[4];\n  e[4] = t;\n  t = e[2];\n  e[2] = e[8];\n  e[8] = t;\n  t = e[3];\n  e[3] = e[12];\n  e[12] = t;\n  t = e[6];\n  e[6] = e[9];\n  e[9] = t;\n  t = e[7];\n  e[7] = e[13];\n  e[13] = t;\n  t = e[11];\n  e[11] = e[14];\n  e[14] = t;\n  return this;\n};\n/**\n * Calculate the inverse matrix of specified matrix, and set to this.\n * @param other The source matrix\n * @return this\n */\n\n\nMatrix4.prototype.setInverseOf = function (other) {\n  var i, s, d, inv, det;\n  s = other.elements;\n  d = this.elements;\n  inv = new Float32Array(16);\n  inv[0] = s[5] * s[10] * s[15] - s[5] * s[11] * s[14] - s[9] * s[6] * s[15] + s[9] * s[7] * s[14] + s[13] * s[6] * s[11] - s[13] * s[7] * s[10];\n  inv[4] = -s[4] * s[10] * s[15] + s[4] * s[11] * s[14] + s[8] * s[6] * s[15] - s[8] * s[7] * s[14] - s[12] * s[6] * s[11] + s[12] * s[7] * s[10];\n  inv[8] = s[4] * s[9] * s[15] - s[4] * s[11] * s[13] - s[8] * s[5] * s[15] + s[8] * s[7] * s[13] + s[12] * s[5] * s[11] - s[12] * s[7] * s[9];\n  inv[12] = -s[4] * s[9] * s[14] + s[4] * s[10] * s[13] + s[8] * s[5] * s[14] - s[8] * s[6] * s[13] - s[12] * s[5] * s[10] + s[12] * s[6] * s[9];\n  inv[1] = -s[1] * s[10] * s[15] + s[1] * s[11] * s[14] + s[9] * s[2] * s[15] - s[9] * s[3] * s[14] - s[13] * s[2] * s[11] + s[13] * s[3] * s[10];\n  inv[5] = s[0] * s[10] * s[15] - s[0] * s[11] * s[14] - s[8] * s[2] * s[15] + s[8] * s[3] * s[14] + s[12] * s[2] * s[11] - s[12] * s[3] * s[10];\n  inv[9] = -s[0] * s[9] * s[15] + s[0] * s[11] * s[13] + s[8] * s[1] * s[15] - s[8] * s[3] * s[13] - s[12] * s[1] * s[11] + s[12] * s[3] * s[9];\n  inv[13] = s[0] * s[9] * s[14] - s[0] * s[10] * s[13] - s[8] * s[1] * s[14] + s[8] * s[2] * s[13] + s[12] * s[1] * s[10] - s[12] * s[2] * s[9];\n  inv[2] = s[1] * s[6] * s[15] - s[1] * s[7] * s[14] - s[5] * s[2] * s[15] + s[5] * s[3] * s[14] + s[13] * s[2] * s[7] - s[13] * s[3] * s[6];\n  inv[6] = -s[0] * s[6] * s[15] + s[0] * s[7] * s[14] + s[4] * s[2] * s[15] - s[4] * s[3] * s[14] - s[12] * s[2] * s[7] + s[12] * s[3] * s[6];\n  inv[10] = s[0] * s[5] * s[15] - s[0] * s[7] * s[13] - s[4] * s[1] * s[15] + s[4] * s[3] * s[13] + s[12] * s[1] * s[7] - s[12] * s[3] * s[5];\n  inv[14] = -s[0] * s[5] * s[14] + s[0] * s[6] * s[13] + s[4] * s[1] * s[14] - s[4] * s[2] * s[13] - s[12] * s[1] * s[6] + s[12] * s[2] * s[5];\n  inv[3] = -s[1] * s[6] * s[11] + s[1] * s[7] * s[10] + s[5] * s[2] * s[11] - s[5] * s[3] * s[10] - s[9] * s[2] * s[7] + s[9] * s[3] * s[6];\n  inv[7] = s[0] * s[6] * s[11] - s[0] * s[7] * s[10] - s[4] * s[2] * s[11] + s[4] * s[3] * s[10] + s[8] * s[2] * s[7] - s[8] * s[3] * s[6];\n  inv[11] = -s[0] * s[5] * s[11] + s[0] * s[7] * s[9] + s[4] * s[1] * s[11] - s[4] * s[3] * s[9] - s[8] * s[1] * s[7] + s[8] * s[3] * s[5];\n  inv[15] = s[0] * s[5] * s[10] - s[0] * s[6] * s[9] - s[4] * s[1] * s[10] + s[4] * s[2] * s[9] + s[8] * s[1] * s[6] - s[8] * s[2] * s[5];\n  det = s[0] * inv[0] + s[1] * inv[4] + s[2] * inv[8] + s[3] * inv[12];\n\n  if (det === 0) {\n    return this;\n  }\n\n  det = 1 / det;\n\n  for (i = 0; i < 16; i++) {\n    d[i] = inv[i] * det;\n  }\n\n  return this;\n};\n/**\n * Calculate the inverse matrix of this, and set to this.\n * @return this\n */\n\n\nMatrix4.prototype.invert = function () {\n  return this.setInverseOf(this);\n};\n/**\n * Set the orthographic projection matrix.\n * @param left The coordinate of the left of clipping plane.\n * @param right The coordinate of the right of clipping plane.\n * @param bottom The coordinate of the bottom of clipping plane.\n * @param top The coordinate of the top top clipping plane.\n * @param near The distances to the nearer depth clipping plane. This value is minus if the plane is to be behind the viewer.\n * @param far The distances to the farther depth clipping plane. This value is minus if the plane is to be behind the viewer.\n * @return this\n */\n\n\nMatrix4.prototype.setOrtho = function (left, right, bottom, top, near, far) {\n  var e, rw, rh, rd;\n\n  if (left === right || bottom === top || near === far) {\n    throw 'null frustum';\n  }\n\n  rw = 1 / (right - left);\n  rh = 1 / (top - bottom);\n  rd = 1 / (far - near);\n  e = this.elements;\n  e[0] = 2 * rw;\n  e[1] = 0;\n  e[2] = 0;\n  e[3] = 0;\n  e[4] = 0;\n  e[5] = 2 * rh;\n  e[6] = 0;\n  e[7] = 0;\n  e[8] = 0;\n  e[9] = 0;\n  e[10] = -2 * rd;\n  e[11] = 0;\n  e[12] = -(right + left) * rw;\n  e[13] = -(top + bottom) * rh;\n  e[14] = -(far + near) * rd;\n  e[15] = 1;\n  return this;\n};\n/**\n * Multiply the orthographic projection matrix from the right.\n * @param left The coordinate of the left of clipping plane.\n * @param right The coordinate of the right of clipping plane.\n * @param bottom The coordinate of the bottom of clipping plane.\n * @param top The coordinate of the top top clipping plane.\n * @param near The distances to the nearer depth clipping plane. This value is minus if the plane is to be behind the viewer.\n * @param far The distances to the farther depth clipping plane. This value is minus if the plane is to be behind the viewer.\n * @return this\n */\n\n\nMatrix4.prototype.ortho = function (left, right, bottom, top, near, far) {\n  return this.concat(new Matrix4().setOrtho(left, right, bottom, top, near, far));\n};\n/**\n * Set the perspective projection matrix.\n * @param left The coordinate of the left of clipping plane.\n * @param right The coordinate of the right of clipping plane.\n * @param bottom The coordinate of the bottom of clipping plane.\n * @param top The coordinate of the top top clipping plane.\n * @param near The distances to the nearer depth clipping plane. This value must be plus value.\n * @param far The distances to the farther depth clipping plane. This value must be plus value.\n * @return this\n */\n\n\nMatrix4.prototype.setFrustum = function (left, right, bottom, top, near, far) {\n  var e, rw, rh, rd;\n\n  if (left === right || top === bottom || near === far) {\n    throw 'null frustum';\n  }\n\n  if (near <= 0) {\n    throw 'near <= 0';\n  }\n\n  if (far <= 0) {\n    throw 'far <= 0';\n  }\n\n  rw = 1 / (right - left);\n  rh = 1 / (top - bottom);\n  rd = 1 / (far - near);\n  e = this.elements;\n  e[0] = 2 * near * rw;\n  e[1] = 0;\n  e[2] = 0;\n  e[3] = 0;\n  e[4] = 0;\n  e[5] = 2 * near * rh;\n  e[6] = 0;\n  e[7] = 0;\n  e[8] = (right + left) * rw;\n  e[9] = (top + bottom) * rh;\n  e[10] = -(far + near) * rd;\n  e[11] = -1;\n  e[12] = 0;\n  e[13] = 0;\n  e[14] = -2 * near * far * rd;\n  e[15] = 0;\n  return this;\n};\n/**\n * Multiply the perspective projection matrix from the right.\n * @param left The coordinate of the left of clipping plane.\n * @param right The coordinate of the right of clipping plane.\n * @param bottom The coordinate of the bottom of clipping plane.\n * @param top The coordinate of the top top clipping plane.\n * @param near The distances to the nearer depth clipping plane. This value must be plus value.\n * @param far The distances to the farther depth clipping plane. This value must be plus value.\n * @return this\n */\n\n\nMatrix4.prototype.frustum = function (left, right, bottom, top, near, far) {\n  return this.concat(new Matrix4().setFrustum(left, right, bottom, top, near, far));\n};\n/**\n * Set the perspective projection matrix by fovy and aspect.\n * @param fovy The angle between the upper and lower sides of the frustum.\n * @param aspect The aspect ratio of the frustum. (width/height)\n * @param near The distances to the nearer depth clipping plane. This value must be plus value.\n * @param far The distances to the farther depth clipping plane. This value must be plus value.\n * @return this\n */\n\n\nMatrix4.prototype.setPerspective = function (fovy, aspect, near, far) {\n  var e, rd, s, ct;\n\n  if (near === far || aspect === 0) {\n    throw 'null frustum';\n  }\n\n  if (near <= 0) {\n    throw 'near <= 0';\n  }\n\n  if (far <= 0) {\n    throw 'far <= 0';\n  }\n\n  fovy = Math.PI * fovy / 180 / 2;\n  s = Math.sin(fovy);\n\n  if (s === 0) {\n    throw 'null frustum';\n  }\n\n  rd = 1 / (far - near);\n  ct = Math.cos(fovy) / s;\n  e = this.elements;\n  e[0] = ct / aspect;\n  e[1] = 0;\n  e[2] = 0;\n  e[3] = 0;\n  e[4] = 0;\n  e[5] = ct;\n  e[6] = 0;\n  e[7] = 0;\n  e[8] = 0;\n  e[9] = 0;\n  e[10] = -(far + near) * rd;\n  e[11] = -1;\n  e[12] = 0;\n  e[13] = 0;\n  e[14] = -2 * near * far * rd;\n  e[15] = 0;\n  return this;\n};\n/**\n * Multiply the perspective projection matrix from the right.\n * @param fovy The angle between the upper and lower sides of the frustum.\n * @param aspect The aspect ratio of the frustum. (width/height)\n * @param near The distances to the nearer depth clipping plane. This value must be plus value.\n * @param far The distances to the farther depth clipping plane. This value must be plus value.\n * @return this\n */\n\n\nMatrix4.prototype.perspective = function (fovy, aspect, near, far) {\n  return this.concat(new Matrix4().setPerspective(fovy, aspect, near, far));\n};\n/**\n * Set the matrix for scaling.\n * @param x The scale factor along the X axis\n * @param y The scale factor along the Y axis\n * @param z The scale factor along the Z axis\n * @return this\n */\n\n\nMatrix4.prototype.setScale = function (x, y, z) {\n  var e = this.elements;\n  e[0] = x;\n  e[4] = 0;\n  e[8] = 0;\n  e[12] = 0;\n  e[1] = 0;\n  e[5] = y;\n  e[9] = 0;\n  e[13] = 0;\n  e[2] = 0;\n  e[6] = 0;\n  e[10] = z;\n  e[14] = 0;\n  e[3] = 0;\n  e[7] = 0;\n  e[11] = 0;\n  e[15] = 1;\n  return this;\n};\n/**\n * Multiply the matrix for scaling from the right.\n * @param x The scale factor along the X axis\n * @param y The scale factor along the Y axis\n * @param z The scale factor along the Z axis\n * @return this\n */\n\n\nMatrix4.prototype.scale = function (x, y, z) {\n  var e = this.elements;\n  e[0] *= x;\n  e[4] *= y;\n  e[8] *= z;\n  e[1] *= x;\n  e[5] *= y;\n  e[9] *= z;\n  e[2] *= x;\n  e[6] *= y;\n  e[10] *= z;\n  e[3] *= x;\n  e[7] *= y;\n  e[11] *= z;\n  return this;\n};\n/**\n * Set the matrix for translation.\n * @param x The X value of a translation.\n * @param y The Y value of a translation.\n * @param z The Z value of a translation.\n * @return this\n */\n\n\nMatrix4.prototype.setTranslate = function (x, y, z) {\n  var e = this.elements;\n  e[0] = 1;\n  e[4] = 0;\n  e[8] = 0;\n  e[12] = x;\n  e[1] = 0;\n  e[5] = 1;\n  e[9] = 0;\n  e[13] = y;\n  e[2] = 0;\n  e[6] = 0;\n  e[10] = 1;\n  e[14] = z;\n  e[3] = 0;\n  e[7] = 0;\n  e[11] = 0;\n  e[15] = 1;\n  return this;\n};\n/**\n * Multiply the matrix for translation from the right.\n * @param x The X value of a translation.\n * @param y The Y value of a translation.\n * @param z The Z value of a translation.\n * @return this\n */\n\n\nMatrix4.prototype.translate = function (x, y, z) {\n  var e = this.elements;\n  e[12] += e[0] * x + e[4] * y + e[8] * z;\n  e[13] += e[1] * x + e[5] * y + e[9] * z;\n  e[14] += e[2] * x + e[6] * y + e[10] * z;\n  e[15] += e[3] * x + e[7] * y + e[11] * z;\n  return this;\n};\n/**\n * Set the matrix for rotation.\n * The vector of rotation axis may not be normalized.\n * @param angle The angle of rotation (degrees)\n * @param x The X coordinate of vector of rotation axis.\n * @param y The Y coordinate of vector of rotation axis.\n * @param z The Z coordinate of vector of rotation axis.\n * @return this\n */\n\n\nMatrix4.prototype.setRotate = function (angle, x, y, z) {\n  var e, s, c, len, rlen, nc, xy, yz, zx, xs, ys, zs;\n  angle = Math.PI * angle / 180;\n  e = this.elements;\n  s = Math.sin(angle);\n  c = Math.cos(angle);\n\n  if (0 !== x && 0 === y && 0 === z) {\n    // Rotation around X axis\n    if (x < 0) {\n      s = -s;\n    }\n\n    e[0] = 1;\n    e[4] = 0;\n    e[8] = 0;\n    e[12] = 0;\n    e[1] = 0;\n    e[5] = c;\n    e[9] = -s;\n    e[13] = 0;\n    e[2] = 0;\n    e[6] = s;\n    e[10] = c;\n    e[14] = 0;\n    e[3] = 0;\n    e[7] = 0;\n    e[11] = 0;\n    e[15] = 1;\n  } else if (0 === x && 0 !== y && 0 === z) {\n    // Rotation around Y axis\n    if (y < 0) {\n      s = -s;\n    }\n\n    e[0] = c;\n    e[4] = 0;\n    e[8] = s;\n    e[12] = 0;\n    e[1] = 0;\n    e[5] = 1;\n    e[9] = 0;\n    e[13] = 0;\n    e[2] = -s;\n    e[6] = 0;\n    e[10] = c;\n    e[14] = 0;\n    e[3] = 0;\n    e[7] = 0;\n    e[11] = 0;\n    e[15] = 1;\n  } else if (0 === x && 0 === y && 0 !== z) {\n    // Rotation around Z axis\n    if (z < 0) {\n      s = -s;\n    }\n\n    e[0] = c;\n    e[4] = -s;\n    e[8] = 0;\n    e[12] = 0;\n    e[1] = s;\n    e[5] = c;\n    e[9] = 0;\n    e[13] = 0;\n    e[2] = 0;\n    e[6] = 0;\n    e[10] = 1;\n    e[14] = 0;\n    e[3] = 0;\n    e[7] = 0;\n    e[11] = 0;\n    e[15] = 1;\n  } else {\n    // Rotation around another axis\n    len = Math.sqrt(x * x + y * y + z * z);\n\n    if (len !== 1) {\n      rlen = 1 / len;\n      x *= rlen;\n      y *= rlen;\n      z *= rlen;\n    }\n\n    nc = 1 - c;\n    xy = x * y;\n    yz = y * z;\n    zx = z * x;\n    xs = x * s;\n    ys = y * s;\n    zs = z * s;\n    e[0] = x * x * nc + c;\n    e[1] = xy * nc + zs;\n    e[2] = zx * nc - ys;\n    e[3] = 0;\n    e[4] = xy * nc - zs;\n    e[5] = y * y * nc + c;\n    e[6] = yz * nc + xs;\n    e[7] = 0;\n    e[8] = zx * nc + ys;\n    e[9] = yz * nc - xs;\n    e[10] = z * z * nc + c;\n    e[11] = 0;\n    e[12] = 0;\n    e[13] = 0;\n    e[14] = 0;\n    e[15] = 1;\n  }\n\n  return this;\n};\n/**\n * Multiply the matrix for rotation from the right.\n * The vector of rotation axis may not be normalized.\n * @param angle The angle of rotation (degrees)\n * @param x The X coordinate of vector of rotation axis.\n * @param y The Y coordinate of vector of rotation axis.\n * @param z The Z coordinate of vector of rotation axis.\n * @return this\n */\n\n\nMatrix4.prototype.rotate = function (angle, x, y, z) {\n  return this.concat(new Matrix4().setRotate(angle, x, y, z));\n};\n/**\n * Set the viewing matrix.\n * @param eyeX, eyeY, eyeZ The position of the eye point.\n * @param centerX, centerY, centerZ The position of the reference point.\n * @param upX, upY, upZ The direction of the up vector.\n * @return this\n */\n\n\nMatrix4.prototype.setLookAt = function (eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {\n  var e, fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;\n  fx = centerX - eyeX;\n  fy = centerY - eyeY;\n  fz = centerZ - eyeZ; // Normalize f.\n\n  rlf = 1 / Math.sqrt(fx * fx + fy * fy + fz * fz);\n  fx *= rlf;\n  fy *= rlf;\n  fz *= rlf; // Calculate cross product of f and up.\n\n  sx = fy * upZ - fz * upY;\n  sy = fz * upX - fx * upZ;\n  sz = fx * upY - fy * upX; // Normalize s.\n\n  rls = 1 / Math.sqrt(sx * sx + sy * sy + sz * sz);\n  sx *= rls;\n  sy *= rls;\n  sz *= rls; // Calculate cross product of s and f.\n\n  ux = sy * fz - sz * fy;\n  uy = sz * fx - sx * fz;\n  uz = sx * fy - sy * fx; // Set to this.\n\n  e = this.elements;\n  e[0] = sx;\n  e[1] = ux;\n  e[2] = -fx;\n  e[3] = 0;\n  e[4] = sy;\n  e[5] = uy;\n  e[6] = -fy;\n  e[7] = 0;\n  e[8] = sz;\n  e[9] = uz;\n  e[10] = -fz;\n  e[11] = 0;\n  e[12] = 0;\n  e[13] = 0;\n  e[14] = 0;\n  e[15] = 1; // Translate.\n\n  return this.translate(-eyeX, -eyeY, -eyeZ);\n};\n/**\n * Multiply the viewing matrix from the right.\n * @param eyeX, eyeY, eyeZ The position of the eye point.\n * @param centerX, centerY, centerZ The position of the reference point.\n * @param upX, upY, upZ The direction of the up vector.\n * @return this\n */\n\n\nMatrix4.prototype.lookAt = function (eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {\n  return this.concat(new Matrix4().setLookAt(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ));\n};\n/**\n * Multiply the matrix for project vertex to plane from the right.\n * @param plane The array[A, B, C, D] of the equation of plane \"Ax + By + Cz + D = 0\".\n * @param light The array which stored coordinates of the light. if light[3]=0, treated as parallel light.\n * @return this\n */\n\n\nMatrix4.prototype.dropShadow = function (plane, light) {\n  var mat = new Matrix4();\n  var e = mat.elements;\n  var dot = plane[0] * light[0] + plane[1] * light[1] + plane[2] * light[2] + plane[3] * light[3];\n  e[0] = dot - light[0] * plane[0];\n  e[1] = -light[1] * plane[0];\n  e[2] = -light[2] * plane[0];\n  e[3] = -light[3] * plane[0];\n  e[4] = -light[0] * plane[1];\n  e[5] = dot - light[1] * plane[1];\n  e[6] = -light[2] * plane[1];\n  e[7] = -light[3] * plane[1];\n  e[8] = -light[0] * plane[2];\n  e[9] = -light[1] * plane[2];\n  e[10] = dot - light[2] * plane[2];\n  e[11] = -light[3] * plane[2];\n  e[12] = -light[0] * plane[3];\n  e[13] = -light[1] * plane[3];\n  e[14] = -light[2] * plane[3];\n  e[15] = dot - light[3] * plane[3];\n  return this.concat(mat);\n};\n/**\n * Multiply the matrix for project vertex to plane from the right.(Projected by parallel light.)\n * @param normX, normY, normZ The normal vector of the plane.(Not necessary to be normalized.)\n * @param planeX, planeY, planeZ The coordinate of arbitrary points on a plane.\n * @param lightX, lightY, lightZ The vector of the direction of light.(Not necessary to be normalized.)\n * @return this\n */\n\n\nMatrix4.prototype.dropShadowDirectionally = function (normX, normY, normZ, planeX, planeY, planeZ, lightX, lightY, lightZ) {\n  var a = planeX * normX + planeY * normY + planeZ * normZ;\n  return this.dropShadow([normX, normY, normZ, -a], [lightX, lightY, lightZ, 0]);\n};\n/**\n * Constructor of Vector3\n * If opt_src is specified, new vector is initialized by opt_src.\n * @param opt_src source vector(option)\n */\n\n\nvar Vector3 = function Vector3(opt_src) {\n  var v = new Float32Array(3);\n\n  if (opt_src && _typeof(opt_src) === 'object') {\n    v[0] = opt_src[0];\n    v[1] = opt_src[1];\n    v[2] = opt_src[2];\n  }\n\n  this.elements = v;\n};\n/**\n  * Normalize.\n  * @return this\n  */\n\n\nVector3.prototype.normalize = function () {\n  var v = this.elements;\n  var c = v[0],\n      d = v[1],\n      e = v[2],\n      g = Math.sqrt(c * c + d * d + e * e);\n\n  if (g) {\n    if (g == 1) return this;\n  } else {\n    v[0] = 0;\n    v[1] = 0;\n    v[2] = 0;\n    return this;\n  }\n\n  g = 1 / g;\n  v[0] = c * g;\n  v[1] = d * g;\n  v[2] = e * g;\n  return this;\n};\n/**\n * Constructor of Vector4\n * If opt_src is specified, new vector is initialized by opt_src.\n * @param opt_src source vector(option)\n */\n\n\nvar Vector4 = function Vector4(opt_src) {\n  var v = new Float32Array(4);\n\n  if (opt_src && _typeof(opt_src) === 'object') {\n    v[0] = opt_src[0];\n    v[1] = opt_src[1];\n    v[2] = opt_src[2];\n    v[3] = opt_src[3];\n  }\n\n  this.elements = v;\n};\n\n\n\n//# sourceURL=webpack:///./pages/test3/matrix.js?");

/***/ })

/******/ });